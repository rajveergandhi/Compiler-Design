%% This is file `elsarticle-template-1-num.tex',
%%
%% Copyright 2009 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%%
%% $Id: elsarticle-template-1-num.tex 149 2009-10-08 05:01:15Z rishi $
%% $URL: http://lenova.river-valley.com/svn/elsbst/trunk/elsarticle-template-1-num.tex $
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% The graphicx package provides the includegraphics command.
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}
\usepackage{paralist}
%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
\usepackage{lineno}

%% natbib.sty is loaded by default. However, natbib options can be
%% provided with \biboptions{...} command. Following options are
%% valid:

%%   round  -  round parentheses are used (default)
%%   square -  square brackets are used   [option]
%%   curly  -  curly braces are used      {option}
%%   angle  -  angle brackets are used    <option>
%%   semicolon  -  multiple citations separated by semi-colon
%%   colon  - same as semicolon, an earlier confusion
%%   comma  -  separated by comma
%%   numbers-  selects numerical citations
%%   super  -  numerical citations as superscripts
%%   sort   -  sorts multiple citations according to order in ref. list
%%   sort&compress   -  like sort, but also compresses numerical citations
%%   compress - compresses without sorting
%%
%% \biboptions{comma,round}

% \biboptions{}


\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

\title{COMP 520 Milestone 2}

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}


%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{<author name>}
%% \address[label1]{<address>}
%% \address[label2]{<address>}

\author{Rajveer Gandhi, Archit Agnihotri, Dipanjan Dutta}

\begin{abstract}
%% Text of abstract
This is a design and implementation report of the Milestone 2 of the GoLite project.
\end{abstract}

\end{frontmatter}

%%
%% Start line numbering here if you want
%%

%% main text
\section{Design Decisions}

Since we got less marks in the Milestone 1 report, we decided to make this report more detailed and descriptive. We decided to include the ideas we missed regarding the scanner, parser and the syntax tree in the first milestone report. In this report, we went for lucidity and reproducibility and made sure that no small details are missed.

In this milestone Dipanjan created the invalid programs and was responsible for the report. Since he is slow in coding and understanding the flex and bison framework and how to code exactly, Dipanjan was also responsible for creating the weeder that we could not implement properly in the first milestone and the entire report. Archit and Raj did the script for symbol table generation and fixed the AST and Pretty printer from Milestone 1. 

\section{Flex and Bison}

In the last report, we mentioned that we chose flex and bison because all of us are comfortable with programming in C. Flex and Bison are frameworks in C that can generate code for C. Our program mainly consists of the following files : 
\begin{itemize}
\item \textbf{src\textbackslash golite.l} : Scanner
\item \textbf{src\textbackslash golite.y} : Parser
\item \textbf{src\textbackslash tree.h} : Header file for syntax tree
\item \textbf{src\textbackslash tree.c} : Syntax tree generator
\item \textbf{src\textbackslash weed.h} : Header file for the weeder
\item \textbf{src\textbackslash weed.c} : Weeder
\item \textbf{src\textbackslash pretty.h} : Header file for the pretty printer
\item \textbf{src\textbackslash pretty.c} : Pretty printer
\item \textbf{src\textbackslash main.c} : Main file which controls execution
\item \textbf{src\textbackslash Makefile} : Script to run flex and bison to create the lexer and parser
\item \textbf{build.sh} : Shell script to clear older versions and run the latest version of \textbf{Makefile}
\item \textbf{run.sh} : Shell script to run \textbf{main.c} on a program file with a specified mode.
\item \textbf{test.sh} : Shell script to test programs (used of internal testing only)
\end{itemize}

The available modes are : 
\begin{itemize}
\item "$scan$" : Scans the program and gives \textbf{OK} if it scans successfully, otherwise throws the error.
\item "$tokens$" : Prints the tokens encountered in order inside the program.
\item "$parse$" : Parses the program, creates the syntax tree and prints \textbf{OK} if successful, otherwise exits after printing the parsing error.
\item "$pretty$" : Pretty prints the program from traversing the syntax tree.
\item "$symbol$" : Generates and prints the symbol table
\item "$typecheck$" : Typechecks the program and prints \textbf{OK} if successful, otherwise exits after printing the typechecking error.
\end{itemize}

\section{Scanner}

The scanner was developed with a very standard setup. We had macros for decimal, octal and hexadecimal representations, and also for escape sequences for runes and strings. Tokens were captured with the help of regular expressions. Every operator has its individual token. We decided not to group operators in order to keep the code more transparent and interpretable.

One challenge that we faced in the scanner was optional semicolons. We had to deal with this by creating a variable called \textit{lastRead}, and updating it whenever a new token is generated (before it is returned). then, when \textit{$\backslash$n} or \textbf{EOF} or block comment including a \textit{$\backslash$n} is encountered we check to see with function \textit{insertSemicolon} if there should have been a semicolon there, and we insert the semicolon in that case.

Another challenge we faced was handling block comments. Dipanjan initially added a state machine implementation of the handling of block comments. However, it was too abstract and none of us knew how exactly it was handling the block comments. So we later decided to switch to regular expressions.

\section{Parser}

Defining the production terms was a bit complex. We had a union structure with all the types of nodes we can have in out syntax tree. We then typed the production nodes according to these node types. Thus the syntax tree was created according to the grammar rules in the parser.

Tokens were aliased with the addition of \textit{t} before their natural names. Almost all the tokens were of type string except integer and float literals which had their respective types. We did not have special tokens for data types and boolean \textit{true} and \textit{false} as they were not reserved keywords in GoLite.

For the error message generation and display, we used bison's error reporting function \textit{yyerror}. 

Associativity and precedence was also defined in the parser. The rule of precedence chosen was (from lower to higher):

\begin{itemize}
\item $=$ (Assignment operator)
\item $||$ (Logical OR operator)
\item $\&\&$ (Logical AND operator)
\item $==$, $!=$, $<$, $>$ $<=$, $>=$
\item $+$, $-$, $|$, (XOR operator)
\item $*$, $/$, $\%$, $<<$, $>>$, $\&$, AND-XOR Operator
\item All unary operators
\end{itemize}

All operators are associated left-to-right, except assignment operator, which is associated right-to-left.

The production rules are created by a joint agreement between all three of us. One thing Dipanjan missed was that typecasting was actually treated as a function call and not a separate expression type. Raj caught that and changed it. 

\section{Syntax tree}

The syntax tree that was in the first milestone had a lot of bugs so Archit decided to create the syntax tree altogether. Previously, we had one single convoluted NODE with different structs for different types. This time around, the node is split up into 23 different types of nodes. It might seem too many nodes but it helps bring clarity to the coding structure and helps traversing the syntax tree intuitive. The different types of nodes that are defined are as follows:
\begin{itemize}
\item $PROGRAM$ : Program node, root or beginning of the tree.
\item $PACKAGE$ : Package declaration.
\item $TOPLEVELDECL$ : Top level declarations. Can be one of the following:
\begin{itemize}
\item $FUNCDCL$ : Function declaration
\item $DCL$ : Non-function declaration. They can be : 
\begin{itemize}
\item $VARDCL$ : Top level variable declaration
\item $TYPEDCL$ : Top level type declaration
\end{itemize}
\end{itemize}
\item $FUNC\_SIGNATURE$ : Function signature.
\item $PARAM\_LIST$ : Parameter list for a function signature.
\item $IDLIST$ : List of identifiers for short declarations, assignments and top-level declarations.
\item $TYPE$ : Type of a declaration.
\item $STRUCT\_TYPE$ : Block of the structure.
\item $BLOCK$ : Block of code enclosed by braces.
\item $STATEMENTS$ : Node acting as a linked list for consecutive statements.
\item $STATEMENT$ : Program statement.
\item $ELSE\_BLOCK$ : Special node for \textit{else} part of an \textit{if} block.
\item $SWITCH\_CONDITION$ : Condition for a switch block.
\item $SWITCH\_CASELIST$ : Linked-list like node for all the cases and default case for the switch block.
\item $EXPRLIST$ : Linked-list like node for expressions (for multiple assignments in one line).
\item $FOR\_CONDITION$ : Node for the condition of a for loop.
\item $SIMPLE$ : Simple statement.
\item $OTHER\_EXPR$ : Other statements (including function calls, struct member selector and slice indexing).
\end{itemize}

\section{Weeder}

The weeder is implemented in order to catch any syntactic errors that might not have been directly caught in the parser's grammar. Dipanjan created the weeder on his own. The following checks were implemented in the weeder:

\subsection{Single default case}
The language specifies that there can only be one default case inside a single switch block. We used a local variable \textit{hasDefault} that is initailly set to zero. If a default case is encountered, it is set to one. If another default case is found while \textit{hasDefault} is 1, we throw an error. We used a local variable to correclt weed through nested switch cases which are recursive calls. Once the switch block is complete, \textit{hasDefault} is set back to zero.

\subsection{Break and continue statements}
According to the language specification, \textit{continue} statements can only appear inside a for loop and \textit{break} statements can only appear inside a for loop or switch block. We had two global static integer variables \textit{insideFor} and \textit{insideSwitch} that stores the level of depth inside a for loop and switch block, respectively ( Initial values of both are zero). When a for loop is encountered, \textit{insideFor} is incremented by 1 and control enters the for loop. When control comes back after finishing the for loop, \textit{insideFor} is decremented by 1. The behaviour is similar for \textit{insideSwitch} as well. If a \textit{continue} statement is encountered when \textit{insideFor} is zero, an error is thrown. If a \textit{break} statement is encountered when both \textit{insideFor} and \textit{insideSwitch} are zero, an error is thrown. Making \textit{insideFor} and \textit{insideSwitch} global and integer helps weed nested loops and nested blocks in a program.

\subsection{Blank identifier}
According to Go specification, blank identifiers can be used :
\begin{itemize}
\item as an identifier in a declaration
\item as an operand on the left side of an assignment
\item as an identifier on left side of $=$ assignment only
\item as a parameter name in function declaration
\end{itemize}
We used a global boolean variable \textit{isBlankIdValid} that is initially set to false. It is set to true before :
\begin{itemize}
\item the weeding of identifier lists of a declaration
\item \textit{LHS} of an assignment statement
\item \textit{LHS} of a short declaration statement
\end{itemize} 
Whenever the recursive weeding of the above are done, the \textit{isBlankIdValid } variable is set to false. If during any expression or statement evaluation, we encounter an "$\_$" we check if \textit{isBlankIdValid} is true or false. If it is false, we throw an error.

\subsection{Unbalanced assignments}
If the \textit{LHS} and the \textit{RHS} of an assignment or declaration statement contain unequal number of operands, the compile should quit with appropriate error. This is implemented with two local variables \textit{lhsCount} and \textit{rhsCount}. The \textit{weedIDLIST} and \textit{weedEXPRLIST} functions return the number of operands in the idlist in the \textit{LHS} of an assignment or declaration, or the number of expressions in the \textit{RHS} of the same. The counters are stored in \textit{lhsCount} and \textit{rhsCount} respectively. If they do not match, an error is thrown. Otherwise, the counters are reset to zero for the next statement.

\subsection{Return statements}
The language specifies that return statements can only be inside a function body. We use a static global integer variable \textit{insideFunction} that is initially set to zero. When we are weeding the function declaration, we increment the \textit{insideFunction} variable by one and then start weeding of the function block. As soon as weeding of the block is done and control comes back, we decrement \textit{insideFuction} by one. If a return statement is encountered and the value of \textit{insideFunction} is zero, an error is thrown. Use of an integer variable allows for weeding of nested functions (which are not supported in the language yet, but its a nice provision to have).


\section{Pretty Printer}

The pretty printer is almost similar in coding structure to the syntax tree. Besides the fact that we implemented a different node structure for syntax tree,  we encountered multiple segmentation faults in Milestone 1 and several other issues. For this reason, we decided to a complete overhaul of the pretty printer. This was done by Archit. 

Previously, we had a single function split into cases based on the kind of statement/expression inside one function. This time around, we created separate functions corresponding to each type of node in the syntax tree for the pretty printer. The $PROGRAM$ is the root node from where the pretty printer starts. Semicolons are printed at the end of every statement.

We also have a separate function, \textit{prettyIndent}, that prints 4 spaces per level of indentation level. Indentation level is stored in a variable $g\_indent$. Every time we enter a block for pretty printing, the $g\_indent$ variable increments by one. On exiting the block, $g\_indent$ is decremented. We decided to print spaces instead of tabs because we have see tabs to create chaotic indentations in several editors. Thus to keep a standard across all platforms for pretty printing, we used spaces.


\section{Symbol Table}

The symbol table script was designed by Raj and Archit. The symbol table was created using a an array of the $SYMBOL$ struct. In a logical sense, the symbol table is designed like a stack of frames, where each frame is associated with its corresponding AST node. The check for printing the symbol table is stored in a external integer variable $g\_tokens$. 

The data structure for the symbol table is as follows:
\begin{itemize}
\item $SymbolTable$ : The main symbol table frame structure. It consists of : 
\begin{itemize}
\item $SYMBOL *table[HashSize]$ : An array of $SYMBOL$ type for symbols in the symbol table. The $HashSize$ is set to be 317.
\item $SymbolTable *parent$ : Pointer to the parent table of the current symbol table (you can think of it as pointer to the previous element in stack)
\end{itemize}
\item $SYMBOL$ : Data structure to define the symbol. It consists of : 
\begin{itemize}
\item $name$ : String to store the name of the symbol.
\item $SYMBOL *next$ : Pointer to the next symbol in the current symbol table.
\item $symTYPE *data$ : Type of the symbol and additional information about the symbol.
\end{itemize}
\item $symTYPE$ : This structure is used to store the type of the symbol. It is used for printing the symbol table and can furthur be used in typechecking. It consists of : 
\begin{itemize}
\item $enum SymbolCategory$ : The category of the symbol. It can be : 
\begin{itemize}
\item $type\_category$ : Declared type.
\item $variable\_category$ : Declared variable.
\item $function\_category$ : Declared function.
\item $constant\_category$ : Used specifically for "true" and "false". It is declared and added to the root symbol table for shadowing in the future.
\end{itemize}
\item $enum symbolType$ : It is used to identify whether it is a function declaration or not (as they are treated differently).
\item $union val$ : This contains a pointer to the $TYPE$ and $FUNC\_SIGNATURE$ nodes of the AST.
\end{itemize}
\end{itemize}

In order to implement the symbol table, we defined some helper functions as well. These functions have some specific purpose, to help with printing the symbol table, to get a symbol from symbol table etc. The functions are described in the following subsections.

\subsection{symIndent}

The $symIndent$ function is used to print proper indentation for the symbol table printing. For every indentation level (tracked by global integer variable $g\_symIndent$) 4 spaces are printed.

\subsection{Hash}

This function is used to create the corresponding hash for a symbol, in order to map and store it in the symbol table. Hashing is done by Division-remainder method.

\subsection{initSymbolTable}

In this function, a node of type $SymbolTable$ is created and initialized. The $table$ array is initialized and all elements are set to null in order to avoid segmentation faults due to bad dereferencing. The parent of the symbol table is also set to null. The newly created symbol table is then returned.

\subsection{scopeSymbolTable}

This function is called when a new sub table (or sub-block or stack element) is to be created with new scope, inside the current symbol table. $initSymbolTable$ is called to create a new $SymbolTable$ frame. The parent of the $SymbolTable$ frame is set to be the symbol table frame in which the scope was at the time of this function call. The function returns the new $SymbolTable$ node.

\subsection{putSymbol}

This function is used to store a symbol in the current scoped $SymbolTable$ frame. 
\begin{itemize}
\item If the symbol is "$\_$", the symbol is not put in the symbol table and a $NULL$ is returned.
\item If the symbol is already defined in the current scoped frame, an error is thrown.
\end{itemize}
Otherwise, the symbol is added to the current frame, along with its type and category. If $g\_tokens$ is 1, the symbol is printed as well. It also returns the symbol.

\subsection{scopeInc and scopeDec}

It increments and decrements the $g\_symIndent$ variable for printing the symbol table, respectively. It also prints the "$\{$" and "$\}$" for the opening and closing of symbol table frame.

\subsection{printSymbol}

This function pretty prints a symbol from the symbol table. First it prints the correct indentation (calls $g\_symIndent$). Then it finds out the category of the symbol and stores it in $sym\_cat$. It then prints according to the type of the symbol. If it is a basic, array, slice or struct type, it calls the $prettyTYPE$ function from the pretty printer. Otherwise, if it is a function declaration, it calls a special pretty printer function $symPrettyFUNC_SIGNATURE$ that prints the function symbol in proper format.

\subsection{getSymbol}

This function is used to fetch a symbol from the symbol table. It uses a recursive approach to traverse through the stack of frames. If, on reaching the root frame, the symbol is not found, an error is thrown stating that the symbol is not declared. If, however, the symbol is found in a frame, it immediately returns the symbol.

\subsection{defSymbol}

This is similar to $getSymbol$, however, it returns a boolean value. It returns true if the symbol is found, false otherwise. It is used in checks while traversing the AST to create the symbol table. The purpose of creating function is to not handle $NULL$ pointers in any check.

\subsection{initSymType}

This function sets the type and category of a symbol and returns a $symTYPE$ variable. It takes a void pointer $p$ that contains the type of the symbol, and the enum value of the symbol type. $p$ is casted appropriately and stored in the $val$ union of the $symTYPE$ node.

$\\$ \par
The symbol table generation is very much similar to the pretty printer or the syntax tree generation. There are, however, a few additional features. 
\setcounter{subsection}0
\subsection{Predeclared symbols}

The symbol table contains the following predeclared symbols : 
\begin{compactenum}
\item \textbf{int}
\item\textbf{float64}
\item\textbf{rune}
\item\textbf{string}
\item\textbf{bool}
\item\textbf{true}
\item\textbf{false}
\end{compactenum}

The last two symbols are of constant type and used for shadowing purposes.

\subsection{Scoping}

The first challenge we faced while generating the symbol table was creating nested scopes/frames. We came up with a plan of creating a new frame (by calling $scopeSymbolTable$) every time we encounter a block of code or branching from the flow of the program. A new frame is created for every : 
\begin{itemize}
\item struct body
\item code enclosed in braces
\item function declaration
\item for loop
\item switch block
\item case in a switch block
\item if block 
\item else-if/else block
\end{itemize} 

All variables in parent frames can be redeclared in these frames but a variable declared in this frame cannot be redeclared in the same frame.

Infinite loops and while loops also have separate frames for symbol table, but thy are essentially the same frame as created for a block of code. For loop can have declaration in the first part of the three-part, thus, we decided to create a separate condition for frame before the recursion.

\subsection{Short Declarations}

Another challenge we faced was to ensure that every short declaration must have at least one undeclared variable. To implement that, we used a local boolean variable $atLeastOneVarNotDeclared$ (initially set to false). We looped through the L.H.S. of the short declaration statement and checked whether a variable is defined in the symbol table or not. If we see that the variable is not defined, we add that variable to the symbol table and change the value of $atLeastOneVarNotDeclared$ to true. If, after traversing through the identifier list in the L.H.S. of the statement, the value of $atLeastOneVarNotDeclared$ is false, we throw an error and exit.

\section{Typechecker}

The typechecker was created in a fashion very similar to what was discussed in the lecture slides. The typechecker has a recursive approach where a program component is well-typed if all its sub-components are well typed and it follows its own typechecking rule.

\subsection{Scoping rules}
The scoping rules are consistent with the Milestone 2 language specifications.
\begin{itemize}
\item Blocks define a scope. Blocks can be : 
\begin{itemize}
\item struct body
\item code enclosed in braces
\item function declaration
\item for loop
\item switch block
\item case in a switch block
\item if block 
\item else-if/else block
\end{itemize} 
\item A variable/type/function declared in a scope can be accessed in that scope
\item A variable/type/function declared in an outer scope can be redeclared in an inner scope.
\item A variable/type/function declared in current scope cannot be redeclared in current scope.
\item A variable/type/function cannot be accessed before declaration. 
\end{itemize}

\subsection{Helper functions}

In order to implement typechecking, we created a few helper functions to perform some tasks need for typechecking.
\begin{itemize}
\item $initTypes$ : Creates the types for the predeclared symbols in the symbol table. ($int$, $float64$, $rune$, $string$, $bool$, "$true$" and "$false$"). "$true$" and "$false$" are set as boolean types for shadowing.
\item $equalTYPE$ : It checks whether two given types are equal or not. If they are equal it returns 1, otherwise it returns 0.
\item $checkBOOL$, $checkRUNE$, $checkSTRING$, $checkINT$ : These four helper functions check whether a given type is the same as one of them or not. If it is not, it gives an error message saying the specified typed is required and returns o. Otherwise, it returns 1.
\end{itemize}

\subsection{Top-level declarations}

A top level declaration can be of three types. Each has its own typechecking rule. 
\begin{itemize}
\item Variable declaration : For every variable declaration in the top-level, we go through the L.H.S. of the declaration ($idlist$) and we see if there is an expression on the R.H.S., it should be well-typed. Then we check for previous declaration of the variable. If undeclared, we add a mapping of the variable to the type of the R.H.S. expression. If it is declared in an outer scope, we create the new mapping as a shadow of the outer mapping. If it is declared in the current scope, we throw an error.
\item Type declaration : Similar to variable declaration. We check if it is declared previously. If undeclared, we add a mapping of the type to the underlying type. If it is declared in an outer scope, we create the new mapping as a shadow of the outer mapping. If it is declared in the current scope, we throw an error.
\item Function declaration : We check the function signature first. If the function of that name is already declared, we throw an error. Otherwise we typecheck the block of the function. We have two special functions that needs to be typechecked with special conditions : 
\begin{itemize}
\item $init$ : The $init$ function cannot have any parameters or return types. It can, however, be redeclared.
\item $main$ : The $main$ function cannot have any parameters or return types.
\end{itemize}
After this we recursive typecheck the block of the function.
\end{itemize}

\subsection{Statements}

Typechecking on statements is done using a linked-list like node $STATEMENTS$. For every statement, typechecking is done recursively for every component of the statement. Note that statements themselves do not have any a type of their own. 
\begin{itemize}
\item Variable and type declarations : Similar to top-level declarations.
\item Blocks : Blocks are typechecked recursively. It is well typed if all the statements in a block are well typed.
\item $break$ and $continue$ statements : These statements are trivially well-typed. Placement of these statements are checked by the prior weeding pass.
\item $return$ statement : $return$ statements are well-typed if : 
\begin{itemize}
\item The $expr$ component is well-typed and the resolved type of $expr$ is the same as the enclosing function return type.
\item There is no $expr$ and the enclosing function has no return type.
\end{itemize}
Also, one thing we missed initially, but caught late on, is that we should typecheck all statements after the $return$ statement, as it can be within a conditional or iterative block inside the function.
\item $if$ block : An $if$ block is well-typed if :
\begin{itemize}
\item Its initial statement is well typed (typechecked recursively for statement)
\item The conditional expression is well-typed and resolves to $bool$
\item The statements in the blocks typecheck (done by recursively typechecking the block)
\end{itemize}
\item $switch$ block : A $switch$ block is well-typed if :
\begin{itemize}
\item Its initial statement is well typed (typechecked recursively for statement)
\item The conditional expression is well-typed
\item The $case$ expressions are well-typed and they resolve to the same type as the $switch$ condition, otherwise an error is thrown.
\item All the statements under every $case$ are recursively typechecked to we well-typed
\item If there is no $switch$ condition (the type of the condition is NULL), then all $case$ expressions must resolve to a $bool$.
\end{itemize}
\item $for$ loops : 
There are 3 kinds of "$for$" loops : 
\begin{itemize}
\item Infinite loop : It is well-typed if its body block is well-typed.
\item "$while$" loop : It is well typed if its conditional expression is well-typed and resolves to $bool$ and its body block is well-typed. If the condition does not resolve to $bool$, an error is thrown.
\item $for$ loop : It has three parts : 
\begin{itemize}
\item The initial statement is recursively checked to be well-typed.
\item The condition typechecks and resolves to $bool$, otherwise an error is thrown.
\item The post-loop operation statement typechecks.
\end{itemize}
If the above three conditions are valid, we typecheck the body of the loop to be well-typed.
\end{itemize}
\item $print$ statements : $print$ and $println$ statements are well-typed if the expressions enclosed in it are all well-typed and resolves to a base type ($int$, $float64$, $rune$, $string$, $bool$). Declared types, even if derived from base types, are not allowed.
\item Empty statements : They are trivially well-typed
\item Increment and decrement statements : These are well-typed if the L.H.S. expression is well-typed and resolves to a numeric base type ($int$, $float64$ or $rune$)
\item Short declarations : This was one of the trickiest typechecks. We checked that : 
\begin{itemize}
\item All expressions on R.H.S. and L.H.S. are well-typed (by recursion)
\item There is one variable in the L.H.S. that is not declared in the current scope (done by using a flag). If all variables are declared in current scope, an error is thrown.
\item The expressions in the R.H.S. must resolve to same type as the corresponding variables in L.H.S. that are declared in current scope (present in the current frame of symbol table).
\end{itemize}
This was one of the hardest typechecking. We performed several tessts on the reference compiler and the Golang compiler and cross-referenced with the given specifications to get it right as much as possible.
\item Assignment statements : For all assignment statements, both L.H.S. and R.H.S. are checked to be well-typed for every corresponding pair, by iterating over the $idlist$ on L.H.S. and recursivey typechecking both L.H.S. and R.H.S. Every variable in the L.H.S. is checked to be already declared. Then for every pair, it is checked that the type of R.H.S. expression is the same as the type of L.H.S. variable as stored in the symbol table. If there is a type mismatch, an error is thrown.
\item Op-assignment statements : Similar to assignment statements. For $v op= expr$, The operator acts as a function that has 2 operand of types $typeof(v)$ and $typeof(expr)$. Unlike assignment statements, the op-assignment returns a value of type same as $typeof(v)$.
\end{itemize}

\subsection{Expressions}

Expressions are typechecked in a way similar to statements. Iterating over the linked-list like node $EXPRLIST$, we typecheck each expression recursively. The type of expression is selected using a switch-case block and typechecking is done according to whichever case is matched with the kind of expression.
\begin{itemize}
\item Expressions with binary operators : They are recursively typechecked for both L.H.S. and R.H.S. If they are well-typed, we check whether they resolve to same types and also, whether these types are accepted by the operator. For this, we used the specification given as reference and mimicked the behavior of the operators as specified. Finally, we return the resolved type of the binary operation according to the specification table given.
\item Unary operations : These are typechecked similar to binary operations. We check if the R.H.S. expression is well-typed. If it is, we look at the operator and see if the R.H.S. type is compatible with the operator (as mentioned in the specification). If so, we return the resolved type of the expression, otherwise we throw an error.
\item Literals : These are trivially well-typed. We only check that a literal node has the corresponding type correct. For example, an $int$ literal should have an $int$ type etc.
\item Identifiers : We check the identifier name in the symbol table. If present, it is well-typed. If it is not found in the symbol table, an error is thrown. 
\item Function calls : This was another difficult typechecking that we had to handle. Our approach was :
\begin{itemize}
\item Recursively check all arguments are well-typed by iterating over the argument list.
\item The function is defined and has the parameter types same as that of the argument list (done by symbol table lookup).
\item The function name is not "$init$" (it cannot be called)
\item Since type casting is also handled as a function call, we handled them under this expression as well :  
\begin{itemize}
\item The type resolves to one of the base types (by string comparison)
\item The expression that is to be cast must be one of the types that are allowed to be cast to the target type. This is done by recursive typechecking the expression. (according to the specification)
\item By recursively accessing the symbol table, we find out the underlying type of the type to be cast to and match it to the type of the expression, or both of them are numeric types, or it behaves like a conversion to string, where $type$ can be $string$ and $expr$ can be an integer ($int$ or $rune$). If not, an error is thrown.
\end{itemize}
\end{itemize}
\item Array or slice indexing : We checked that the name of the array or slice is well-typed and present in the symbol table. Then we checked that the index specified is of type $int$. If so, then the expression return a type same as that specified in the symbol table. We do not check for out-of-bounds access.
\item Struct member access : For expression like $a.x$, we : 
\begin{itemize}
\item Checked the type of $a$ in the symbol table and if it is not a struct, we threw an error. 
\item Checked if the nested symbol table frame of that struct has a field declared called $x$. If not, an error is thrown.
\end{itemize}
If both of these are valid, the expression returns the type of the variable$x$, as defined in the struct.
\end{itemize}

\section{Invalid programs and their typing rule violation}
\begin{enumerate}
\item $incompatible\_type\_append\_with\_slices.go$ : $append$ is well-typed if the first term is a slice and the second term is of the same type as first type. Here, they have different type aliases (even though they derive the same base type).

\item $incorrect\_number\_of\_function\_call\_arguments.go$ : A function call is well-typed if all of its arguments are well-typed and it has the same number of arguments and the types of arguments are same as corresponding types of parameters. Her, the number of arguments do not match the number of parameters.

\item $incorrect\_assignment\_of\_function\_return\_value.go$ : An assignment statement is well-typed if both L.H.S. and R.H.S. are well typed and type of every pair of corresponding $lvalue$ and expression is the same. In this program, the function returns a $float64$ but the variable it is stored into is of type $int$.

\item $invalid\_adding\_bool\_and\_string.go$ : A $+$ operation requires both its operands to be either numeric or string. In this program, the L.H.S. operand is of type boolean, which is a violation.
\item $invalid\_function\_return\_value\_diff\_type\_alias\_arrays.go$ : The return statement is well typed if : 
\begin{itemize}
\item It has no expression and its enclosing function has no return type
\item The type of the expression of return statement is the same as the function's return type.
\end{itemize}
In this program, the return type of the function is $[5]num2$ but the function returns $[5]num1$ (even though both $num1$ and $num2$ have same base types).

\item $invalid\_assignment\_return\_value\_array\_size\_mismatch.go$ : Same rule as no. $3$. Here the function returns $[5]int$ but the value is stored in a variable of type $[6]int$

\item $invalid\_function\_return\_statement.go$ : Same typing rule as no. $5$. Here the return type of the function is $int$ but the function does not return anything (returns a void or null, to say).

\item $invalid\_function\_return\_value\_diff\_type\_alias.go$ : Same typing rule as no. $5$. In this program, the return type of the function is $num2$ but the function returns $num1$ (even though both $num1$ and $num2$ have same base types).

\item $invalid\_int\_condition\_in\_if.go$ : An if statement type checks if:
\begin{itemize}
\item Initial declaration, if present, type checks
\item Condition expression is well-typesd and resolves to type $bool$
\item Statements in the $if$ block typechecks
\item Statements in $else-if$/$else$ blocks typecheck
\end{itemize}
In this program, the expression is well-typed but resolves to an $int$ type instead of a $bool$ type.

\item $invalid\_return\_int\_in\_void\_function.go$ : Same typing rule as no. $5$. Here, the function has no return type, but inside the function body, it return an $int$ value.

\item $invalid\_return\_statement\_in\_function.go$ : Same typing rule as $5$. Here, the function has $int$ return type, but inside the function body, it return a $string$ value.

\item $invalid\_short\_dec\_type\_mismatch\_declared\_var.go$ : A short declaration is well-typed if : 
\begin{itemize}
\item All the expressions in R.H.S. are well typed
\item At least one variable in L.H.S. is undeclared
\item Declared variables in L.H.S. and corresponding expressions in R.H.S. must be of the same type.
\end{itemize}
In this program, the third clause is violated. Variable $a$, already declared as $int$, is assigned a $string$ value.

\item $invalid\_string\_decrement.go$ : Increment/decrement statements are well-typed if their expressions are well-typed and resolve to a numeric base type ($int$, $float64$ or $rune$). Here, decrement operation is done on a $string$ expression.

\item $invalid\_struct\_member\_assignment.go$ : A field selection $expr.id$ is well-typed if the expression is of a type that resolves to a struct and that struct contains the $id$. Here, $p$ is of type $a$ that has an $int$ variable $x$, but it is being assigned a $string$ value.

\item $invalid\_type\_assignment.go$ : Same typing rule as no. $3$. Here, $p.y$ is of type $a$ but the R.H.S. is of type $c$ ( even though the structs $a$ and $c$ have identical structure).

\item $invalid\_type\_comparison.go$ : The binary expression $==$ is well typed if both the operands are comparable (both of same types). Here, the operands are of type $num1$ and $num2$ respectively, hence they are in violation (even though the base types of $num1$ and $num2$ are $int$).

\item $invalid\_type\_comparison\_2.go$ : Same typing rule as no. $16$. Here the variables are of types $num1$ and $num2$, but the $num2$ type is of type $num1$. However, they are still different types, so they are in conflict with the typing rule.

\item $invalid\_type\_comparison\_3.go$ : Same typing rule as no. $16$. Here the two variables compared have two different struct types.

\item $invalid\_typecasting\_from\_string\_to\_int.go$ : A type cast $type(expr)$ is well typed if : 
\begin{itemize}
\item $type$ is well typed and resolves to a base type
\item $expr$ is well typed and satisfies one of the three conditions : 
\begin{enumerate}
\item $type$ and $expr$ resolve to underlying same types
\item $type$ and $expr$ resolve to numeric types
\item $type$ resolves to $string$ and $expr$ resolves to $rune$ or $int$
\end{enumerate}
\end{itemize}
Here, integer type casting is done in a $string$ variable, which is in violation with the above rule.

\item $invalid\_unary\_not\_op\_on\_int.go$ : The unary logical $NOT$ expression is well typed if the R.H.S. expression resolves to a $bool$ value. In this program, $NOT$  is done on an $int$ variable.

\item $invalid\_unary\_operation\_on\_string.go$ : The unary minus expression is well typed if the R.H.S. expression is well typed and resolves to a numeric type ($int$, $float64$ or $rune$). Here, the unary minus is implemented on a $string $ variable.

\item $invalid_usage_of_variable_before_declaration.go$ : In GoLite, identifiers must be declared before they are used. In this program, $a$ is initialized with the value of $b$, but $b$ is declared after $a$.

\item $invalid\_use\_of\_or\_operator.go$ : The binary operation $||$ (logical $OR$) is well typed if both its operands resolve to $bool$ types. In this program, both the operands for the $||$ operation are $int$ values, which are not supported in GoLite.

\item $invalid\_variable\_array\_size\_declaration.go$ : In GoLite, arrays declared must have a constant size and the size cannot be a variable. This program is in direct conflict with that rule.

\item $invalid\_while\_loop\_int\_condition.go$ : The condition for $while$ loop must resolve to a $bool$ value. However, in this program, the condition for the $while$ loop has an $int$ type.

\item $mismatched\_type\_in\_op\_assignment.go$ : In Go, the "$+=$" operation requires both its operands to be of same type. In this program, L.H.S operand is of type $float64$ and R.H.S. operand is of type $int$.

\item $redeclaration\_of\_variable\_in\_same\_scope.go$ : This is actually in violation of a scoping rule. According to the scoping rules, a variable declared in a higher scope can be redeclared in a lower scope, but a variable (re)declared in a certain scope cannot be redeclared in the same scope (which is what is being implemented in this program).

\item $switch\_case\_expression\_type\_mismatch.go$ : In a switch statement, the case expressions must have the same type as the switch condition. In this program, the switch condition expression is of type $int$ but the case expressions are of type $rune$.

\item $type\_redeclaration.go$ : This program violates the same scoping rule as no. $27$, which is applicable for types as well.

\item $undeclared\_variable.go$ : A variable cannot be used or accessed without declaring it, either by $var$ or "$:=$" declarations.

\item $invalid\_modulo\_op\_rune\_float.go$ : A modulo ($\%$) operation is well typed if both its operands are integer values ($int$ or $rune$). In this program, the $\%$ operation is done on a $rune$ and a $float64$ operand.
\end{enumerate}

\section{Team member contribution}
\begin{itemize}
\item \textbf{Archit Agnihotri}
\begin{itemize}
\item Corrected the AST and pretty printer from Milestone 1
\item Created the symbol table
\item Created the typechecker
\end{itemize}
\item \textbf{Rajveer Gandhi}
\begin{itemize}
\item Created the symbol table
\item Created the typechecker
\end{itemize}
\item \textbf{Dipanjan Dutta}
\begin{itemize}
\item Corrected the weeder from Milestone 1
\item Created the invalid programs
\item Created the report
\end{itemize}
\item \textbf{All of us}
\begin{itemize}
\item Tested and debugged the programs
\end{itemize}
\end{itemize}
%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

%% \section{}
%% \label{}

%% References
%%
%% Following citation commands can be used in the body text:
%% Usage of \cite is as follows:
%%   \cite{key}          ==>>  [#]
%%   \cite[chap. 2]{key} ==>>  [#, chap. 2]
%%   \citet{key}         ==>>  Author [#]

%% References with bibTeX database:

\bibliographystyle{model1-num-names}
\bibliography{sample.bib}



\end{document}

